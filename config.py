# -*- coding: utf-8 -*-

"""
File for dealing with the configuration of Pi2O.py.
"""

import os
import logging
import threading
from ConfigParser import SafeConfigParser, NoSectionError

from zone import GPIORelay, SprinklerZone

__version__ = '0.4'
__all__ = ['CONFIG_FILE', 'LockingConfigParser', 'loadConfig', 'initZones', 'saveConfig', 
           '__version__']


# Logger instance
confLogger = logging.getLogger('__main__')


# Maximum number of zones to configure
MAX_ZONES = 4


# Files
## Base path for the various files needed/generated by Pi2O.py
_BASE_PATH = os.path.dirname(os.path.abspath(__file__))

## Configuration
CONFIG_FILE = os.path.join(_BASE_PATH, 'Pi2O.config')


class LockingConfigParser(SafeConfigParser):
    """
    Sub-class of ConfigParser.SafeConfigParser that wraps the get, set, and 
    write methods with a semaphore to ensure that only one get/set/read/write 
    happens at a time.  The sub-class also adds asDict and fromDict methods
    to make it easier to tie the configuration into webforms.
    """
    
    _lock = threading.Semaphore()
    
    def get(self, *args, **kwds):
        """
        Locked get() method.
        """
        
        #self._lock.acquire()
        value = SafeConfigParser.get(self, *args, **kwds)
        #self._lock.release()
        return value
        
    def getint(self, *args, **kwds):
        """
        Locked getint() method.
        """
        
        value = SafeConfigParser.getint(self, *args, **kwds)
        return int(value)
        
    def getfloat(self, *args, **kwds):
        """
        Locked getfloat() method.
        """
        
        value = SafeConfigParser.getfloat(self, *args, **kwds)
        return float(value)
        
    def set(self, *args, **kwds):
        """
        Locked set() method.
        """
        
        #self._lock.acquire()
        SafeConfigParser.set(self, *args, **kwds)
        #self._lock.release()
        
    def read(self, *args, **kwds):
        """
        Locked read() method.
        """
        
        SafeConfigParser.read(self, *args, **kwds)
        
    def write(self, *args, **kwds):
        """
        Locked write() method.
        """
        
        SafeConfigParser.write(self, *args, **kwds)
        
    def asDict(self):
        """
        Return the configuration as a dictionary with keys structured as
        section-option.
        """
        
        configDict = {}
        for section in self.sections():
            for keyword,value in self.items(section):
                configDict['%s-%s' % (section.lower(), keyword.replace('_', '-'))] = value
        
        # Done
        return configDict
        
    def fromDict(self, configDict):
        """
        Given a dictionary created by asDict(), update the configuration 
        as needed.
        """
        
        # Loop over the pairs in the dictionary
        for key,value in configDict.iteritems():
            try:
                section, keyword = key.split('-', 1)
                keyword = keyword.replace('-', '_')
                section = section.capitalize()
                self.set(section, keyword, value)
            except Exception, e:
                print str(e)
                pass
                
        # Done
        return True


def loadConfig(filename):
    """
    Read in the configuration file and return a LockingConfigParser instance.
    """
    
    # Initial configuration file
    config = LockingConfigParser()
    
    ## Dummy information about the four zones:
    ##  1) name - zone nickname
    ##  2) pin - RPi GPIO pin
    ##  3) rate - precipitation rate in inches per hour
    ##  4) enabled - whether or not the zone is active
    ##  _) current_et_value - hidden value to record the ET between restarts
    for zone in xrange(1, MAX_ZONES+1):
        config.add_section('Zone%i' % zone)
        for keyword in ('name', 'pin', 'rate', 'enabled', 'current_et_value'):
            config.set('Zone%i' % zone, keyword, '')
            if keyword == 'enabled':
                config.set('Zone%i' % zone, keyword, 'off')
            elif keyword in ('rate', 'current_et_value'):
                config.set('Zone%i' % zone, keyword, '0.0')
                
    ## Dummy schedule information - one for each month
    ##  1) start - start time as HH:MM, 24-hour format
    ##  2) threshold - accumulated ET threshold before watering
    ##  3) enabled - whether or not the schedule is active
    for month in xrange(1, 13):
        config.add_section('Schedule%i' % month)
        for keyword in ('start', 'threshold', 'enabled'):
            if keyword == 'threshold':
                config.set('Schedule%i' % month, keyword, '0.5')
            else:
                config.set('Schedule%i' % month, keyword, '')
                
    ## Dummy weather station information
    ##  1) pws - PWS ID to use for weather info
    config.add_section('Weather')
    for keyword in ('pws',):
        config.set('Weather', keyword, '')
        
    # Try to read in the actual configuration file
    try:
        config.read(filename)
        confLogger.info('Loaded configuration from \'%s\'', os.path.basename(filename))
        
    except:
        pass
        
    # Done
    return config


def initZones(config):
    """
    Given a LockingConfigParser configuration instance, create a list of 
    SprinklerZone instances to control the various zones.
    """
    
    # Create the list of SprinklerZone instances
    zones = []
    zone = 1
    while True:
        try:
            ## Is the zone enabled?
            zoneEnabled = config.get('Zone%i' % zone, 'enabled')
            if zoneEnabled == 'on':
                ### If so, use the real GPIO pin
                zonePin = config.getint('Zone%i' % zone, 'pin')
            else:
                ### If not, use a dummy pin
                zonePin = -1
                
            ## Create the SprinklerZone instance
            zones.append( SprinklerZone(zonePin, 
                                        rate=config.getfloat('Zone%i' % zone, 'rate'), 
                                        current_et_value=config.getfloat('Zone%i' % zone, 'current_et_value'))
                        )
            
            ## Update the counter
            zone += 1
            
        except NoSectionError:
            break
            
    # Done
    return zones


def saveConfig(filename, config):
    """
    Given a filename and a LockingConfigParser, write the configuration to 
    disk.
    """
    
    fh = open(filename, 'w')
    config.write(fh)
    fh.close()
    
    confLogger.info('Saved configuration to \'%s\'', os.path.basename(filename))
